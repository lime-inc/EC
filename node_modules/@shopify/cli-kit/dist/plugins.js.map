{"version":3,"file":"plugins.js","sourceRoot":"","sources":["../src/plugins.ts"],"names":[],"mappings":"AAIA,OAAO,EAAC,kBAAkB,EAAE,eAAe,EAAC,MAAM,YAAY,CAAA;AAG9D;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,WAAW,CAC/B,MAAyB,EACzB,KAAa,EACb,OAA4C,EAC5C,OAAgB;IAEhB,MAAM,GAAG,GAAG,MAAM,MAAM,CAAC,OAAO,CAAC,KAAK,EAAE,OAAO,EAAE,OAAO,CAAC,CAAA;IACzD,8DAA8D;IAC9D,OAAO,MAAM,CAAC,WAAW,CAAC,GAAG,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,EAAC,MAAM,EAAE,MAAM,EAAC,EAAE,EAAE,CAAC,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAQ,CAAA;AAClG,CAAC;AAmCD;;;;;;GAMG;AACH,MAAM,CAAC,KAAK,UAAU,sBAAsB,CAAC,MAAc;IACzD,MAAM,KAAK,GAAG,MAAM,WAAW,CAAC,MAAM,EAAE,iBAAiB,EAAE,EAAE,CAAC,CAAA;IAC9D,MAAM,KAAK,GAAG,eAAe,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAA;IAC3E,IAAI,kBAAkB,CAAC,KAAK,CAAC;QAAE,OAAO,EAAC,OAAO,EAAE,KAAK,EAAE,KAAK,EAAE,+BAA+B,EAAC,CAAA;IAC9F,OAAO,EAAC,OAAO,EAAE,KAAK,EAAC,CAAA;AACzB,CAAC;AAED;;;;;;;;GAQG;AACH,MAAM,CAAC,KAAK,UAAU,eAAe,CACnC,MAAc,EACd,IAAY,EACZ,QAAgB;IAEhB,MAAM,KAAK,GAAG,MAAM,WAAW,CAAC,MAAM,EAAE,cAAc,EAAE,EAAC,IAAI,EAAE,QAAQ,EAAC,CAAC,CAAA;IACzE,MAAM,IAAI,GAAG,eAAe,CAAC,MAAM,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC,CAAA;IACzE,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC;QAAE,OAAO,EAAC,KAAK,EAAE,eAAe,EAAC,CAAA;IACpD,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO,EAAC,KAAK,EAAE,SAAS,EAAC,CAAA;IAChD,OAAO,EAAC,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC,EAAC,CAAA;AACvB,CAAC","sourcesContent":["import {JsonMap} from './json.js'\nimport {PickByPrefix} from './typing/pick-by-prefix.js'\nimport {MonorailEventPublic} from './monorail.js'\nimport {HookReturnPerTunnelPlugin} from './plugins/tunnel.js'\nimport {containsDuplicates, filterUndefined} from './array.js'\nimport {Config, Interfaces} from '@oclif/core'\n\n/**\n * Convenience function to trigger a hook, and gather any successful responses. Failures are ignored.\n *\n * Responses are organised into a dictionary, keyed by plug-in name. Only plug-ins that have hooks registered for the given event, and the hooks were run successfully, are included.\n */\nexport async function fanoutHooks<TPluginMap extends HookReturnsPerPlugin, TEvent extends string & keyof TPluginMap>(\n  config: Interfaces.Config,\n  event: TEvent,\n  options: TPluginMap[typeof event]['options'],\n  timeout?: number,\n): Promise<Partial<TPluginMap[typeof event]['pluginReturns']>> {\n  const res = await config.runHook(event, options, timeout)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return Object.fromEntries(res.successes.map(({result, plugin}) => [plugin.name, result])) as any\n}\n\ntype AppSpecificMonorailFields = PickByPrefix<MonorailEventPublic, 'app_', 'project_type' | 'api_key' | 'partner_id'> &\n  PickByPrefix<MonorailEventPublic, 'cmd_extensions_'> &\n  PickByPrefix<MonorailEventPublic, 'cmd_scaffold_'>\n\ninterface HookReturnsPerPlugin extends HookReturnPerTunnelPlugin {\n  public_command_metadata: {\n    options: {[key: string]: never}\n    pluginReturns: {\n      '@shopify/app': Partial<AppSpecificMonorailFields>\n      [pluginName: string]: JsonMap\n    }\n  }\n  [hookName: string]: {\n    options: {[key: string]: unknown}\n    pluginReturns: {[key: string]: JsonMap}\n  }\n}\n\nexport type PluginReturnsForHook<\n  TEvent extends keyof TPluginMap,\n  TPluginName extends keyof TPluginMap[TEvent]['pluginReturns'],\n  TPluginMap extends HookReturnsPerPlugin = HookReturnsPerPlugin,\n> = TPluginMap[TEvent]['pluginReturns'][TPluginName]\n\nexport type FanoutHookFunction<\n  TEvent extends keyof TPluginMap = string,\n  TPluginName extends keyof TPluginMap[TEvent]['pluginReturns'] = string,\n  TPluginMap extends HookReturnsPerPlugin = HookReturnsPerPlugin,\n> = (\n  this: Interfaces.Hook.Context,\n  options: TPluginMap[TEvent]['options'] & {config: Interfaces.Config},\n) => Promise<PluginReturnsForHook<TEvent, TPluginName, TPluginMap>>\n\n/**\n * Execute the 'tunnel_provider' hook, and return the list of available tunnel providers.\n * Fail if there are multiple plugins for the same provider\n *\n * @param config oclif config used to execute hooks\n * @returns list of available tunnel plugins\n */\nexport async function getListOfTunnelPlugins(config: Config): Promise<{plugins: string[]; error?: string}> {\n  const hooks = await fanoutHooks(config, 'tunnel_provider', {})\n  const names = filterUndefined(Object.values(hooks).map((key) => key?.name))\n  if (containsDuplicates(names)) return {plugins: names, error: 'multiple-plugins-for-provider'}\n  return {plugins: names}\n}\n\n/**\n * Execute the 'tunnel_start' hook for the given provider.\n * Fails if there aren't plugins for that provider or if there are more than one.\n *\n * @param config oclif config used to execute hooks\n * @param port port where the tunnel will be started\n * @param provider selected provider, must be unique\n * @returns tunnel URL from the selected provider\n */\nexport async function runTunnelPlugin(\n  config: Config,\n  port: number,\n  provider: string,\n): Promise<{url?: string; error?: string}> {\n  const hooks = await fanoutHooks(config, 'tunnel_start', {port, provider})\n  const urls = filterUndefined(Object.values(hooks).map((key) => key?.url))\n  if (urls.length > 1) return {error: 'multiple-urls'}\n  if (urls.length === 0) return {error: 'no-urls'}\n  return {url: urls[0]}\n}\n"]}