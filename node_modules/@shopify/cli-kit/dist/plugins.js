import { containsDuplicates, filterUndefined } from './array.js';
/**
 * Convenience function to trigger a hook, and gather any successful responses. Failures are ignored.
 *
 * Responses are organised into a dictionary, keyed by plug-in name. Only plug-ins that have hooks registered for the given event, and the hooks were run successfully, are included.
 */
export async function fanoutHooks(config, event, options, timeout) {
    const res = await config.runHook(event, options, timeout);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return Object.fromEntries(res.successes.map(({ result, plugin }) => [plugin.name, result]));
}
/**
 * Execute the 'tunnel_provider' hook, and return the list of available tunnel providers.
 * Fail if there are multiple plugins for the same provider
 *
 * @param config oclif config used to execute hooks
 * @returns list of available tunnel plugins
 */
export async function getListOfTunnelPlugins(config) {
    const hooks = await fanoutHooks(config, 'tunnel_provider', {});
    const names = filterUndefined(Object.values(hooks).map((key) => key?.name));
    if (containsDuplicates(names))
        return { plugins: names, error: 'multiple-plugins-for-provider' };
    return { plugins: names };
}
/**
 * Execute the 'tunnel_start' hook for the given provider.
 * Fails if there aren't plugins for that provider or if there are more than one.
 *
 * @param config oclif config used to execute hooks
 * @param port port where the tunnel will be started
 * @param provider selected provider, must be unique
 * @returns tunnel URL from the selected provider
 */
export async function runTunnelPlugin(config, port, provider) {
    const hooks = await fanoutHooks(config, 'tunnel_start', { port, provider });
    const urls = filterUndefined(Object.values(hooks).map((key) => key?.url));
    if (urls.length > 1)
        return { error: 'multiple-urls' };
    if (urls.length === 0)
        return { error: 'no-urls' };
    return { url: urls[0] };
}
//# sourceMappingURL=plugins.js.map