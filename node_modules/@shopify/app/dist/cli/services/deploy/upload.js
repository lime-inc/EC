import { themeExtensionConfig as generateThemeExtensionConfig } from './theme-extension-config.js';
import { blocks } from '../../constants.js';
import { api, error, session, http, id, output, file } from '@shopify/cli-kit';
import fs from 'fs';
/**
 * Uploads theme extension(s)
 * @param options {DeployThemeExtensionOptions} The upload options
 */
export async function uploadThemeExtensions(themeExtensions, options) {
    const { apiKey, identifiers, token } = options;
    await Promise.all(themeExtensions.map(async (themeExtension) => {
        const themeExtensionConfig = await generateThemeExtensionConfig(themeExtension);
        const themeId = identifiers.extensionIds[themeExtension.localIdentifier];
        const themeExtensionInput = {
            apiKey,
            config: JSON.stringify(themeExtensionConfig),
            context: undefined,
            registrationId: themeId,
        };
        const mutation = api.graphql.ExtensionUpdateDraftMutation;
        const result = await api.partners.request(mutation, token, themeExtensionInput);
        if (result.extensionUpdateDraft?.userErrors?.length > 0) {
            const errors = result.extensionUpdateDraft.userErrors.map((error) => error.message).join(', ');
            throw new error.Abort(errors);
        }
    }));
}
/**
 * Uploads a bundle.
 * @param options {UploadUIExtensionsBundleOptions} The upload options
 */
export async function uploadUIExtensionsBundle(options) {
    const deploymentUUID = id.generateRandomUUID();
    const signedURL = await getUIExtensionUploadURL(options.apiKey, deploymentUUID);
    const formData = http.formData();
    const buffer = fs.readFileSync(options.bundlePath);
    formData.append('my_upload', buffer);
    await http.fetch(signedURL, {
        method: 'put',
        body: buffer,
        headers: formData.getHeaders(),
    });
    const variables = {
        apiKey: options.apiKey,
        uuid: deploymentUUID,
        bundleUrl: signedURL,
        extensions: options.extensions,
    };
    const mutation = api.graphql.CreateDeployment;
    const result = await api.partners.request(mutation, options.token, variables);
    if (result.deploymentCreate?.userErrors?.length > 0) {
        const errors = result.deploymentCreate.userErrors.map((error) => error.message).join(', ');
        throw new error.Abort(errors);
    }
    const validationErrors = result.deploymentCreate.deployment.deployedVersions
        .filter((ver) => ver.extensionVersion.validationErrors.length > 0)
        .map((ver) => {
        return { uuid: ver.extensionVersion.registrationUuid, errors: ver.extensionVersion.validationErrors };
    });
    return validationErrors;
}
/**
 * It generates a URL to upload an app bundle.
 * @param apiKey {string} The application API key
 * @param deploymentUUID {string} The unique identifier of the deployment.
 * @returns
 */
export async function getUIExtensionUploadURL(apiKey, deploymentUUID) {
    const mutation = api.graphql.GenerateSignedUploadUrl;
    const token = await session.ensureAuthenticatedPartners();
    const variables = {
        apiKey,
        deploymentUuid: deploymentUUID,
        bundleFormat: 1,
    };
    const result = await api.partners.request(mutation, token, variables);
    if (result.deploymentGenerateSignedUploadUrl?.userErrors?.length > 0) {
        const errors = result.deploymentGenerateSignedUploadUrl.userErrors.map((error) => error.message).join(', ');
        throw new error.Abort(errors);
    }
    return result.deploymentGenerateSignedUploadUrl.signedUploadUrl;
}
/**
 * This function takes a list of function extensions and uploads them.
 * As part of the upload it creates a function server-side if it does not exist
 * and includes its remote identifier in the returned identifiers instance.
 * If the function already has a local id, that one is used and the upload
 * does an override of the function existing server-side.
 *
 * @param extensions {FunctionExtension[]} The list of extensions to upload.
 * @param options {UploadFunctionExtensionsOptions} Options to adjust the upload.
 * @returns {Promise<Identifiers>} A promise that resolves with the identifiers.
 */
export async function uploadFunctionExtensions(extensions, options) {
    let identifiers = options.identifiers;
    const functionIds = {};
    // Functions are uploaded sequentially to avoid reaching the API limit
    for (const extension of extensions) {
        // eslint-disable-next-line no-await-in-loop
        const remoteIdentifier = await uploadFunctionExtension(extension, {
            apiKey: options.identifiers.app,
            token: options.token,
            identifier: identifiers.extensions[extension.localIdentifier],
        });
        functionIds[extension.localIdentifier] = remoteIdentifier;
    }
    identifiers = {
        ...identifiers,
        extensions: {
            ...identifiers.extensions,
            ...functionIds,
        },
    };
    return identifiers;
}
async function uploadFunctionExtension(extension, options) {
    const { url, headers } = await getFunctionExtensionUploadURL({ apiKey: options.apiKey, token: options.token });
    headers['Content-Type'] = 'application/wasm';
    let inputQuery;
    if (await file.exists(extension.inputQueryPath())) {
        inputQuery = await file.read(extension.inputQueryPath());
    }
    const functionContent = fs.readFileSync(extension.buildWasmPath());
    await http.fetch(url, { body: functionContent, headers, method: 'PUT' });
    await compileFunctionExtension(extension, options, url);
    const query = api.graphql.AppFunctionSetMutation;
    const variables = {
        // NOTE: This is a shim to support CLI projects that currently use the UUID instead of the ULID
        ...(options.identifier?.includes('-') ? { legacyUuid: options.identifier } : { id: options.identifier }),
        title: extension.configuration.name,
        description: extension.configuration.description,
        apiType: extension.configuration.type,
        apiVersion: extension.configuration.apiVersion,
        inputQuery,
        appBridge: extension.configuration.ui?.paths
            ? {
                detailsPath: extension.configuration.ui.paths.details,
                createPath: extension.configuration.ui.paths.create,
            }
            : undefined,
        moduleUploadUrl: url,
    };
    const res = await api.partners.functionProxyRequest(options.apiKey, query, options.token, variables);
    const userErrors = res.data.functionSet.userErrors ?? [];
    if (userErrors.length !== 0) {
        const errorMessage = output.content `The deployment of functions failed with the following errors:
${output.token.json(userErrors)}
    `;
        throw new error.Abort(errorMessage);
    }
    return res.data.functionSet.function?.id;
}
async function compileFunctionExtension(extension, options, moduleUploadUrl) {
    const query = api.graphql.CompileModuleMutation;
    const variables = {
        moduleUploadUrl,
    };
    const res = await api.partners.functionProxyRequest(options.apiKey, query, options.token, variables);
    const jobId = res.data.compileModule.jobId;
    await waitForCompilation(extension, options, jobId);
}
async function getCompilationStatus(options, compilationJobId) {
    const query = api.graphql.ModuleCompilationStatusQuery;
    const variables = {
        jobId: compilationJobId,
    };
    const res = await api.partners.functionProxyRequest(options.apiKey, query, options.token, variables);
    return res.data.moduleCompilationStatus.status;
}
async function waitForCompilation(extension, options, compilationJobId) {
    let retries = 0;
    const poll = async () => {
        const compilationStatus = await getCompilationStatus(options, compilationJobId);
        // eslint-disable-next-line no-empty
        if (compilationStatus === 'completed') {
        }
        else if (compilationStatus !== 'pending') {
            throw new error.Abort(output.content `Function ${extension.localIdentifier} compilation failed.`);
        }
        else if (retries < blocks.functions.maxCompilationStatusCheckCount) {
            retries++;
            return sleep(blocks.functions.compilationStatusWaitMs).then(() => poll());
        }
        else {
            throw new error.Abort(output.content `Function ${extension.localIdentifier} compilation timed out.`);
        }
    };
    return poll();
}
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
async function getFunctionExtensionUploadURL(options) {
    const query = api.graphql.UploadUrlGenerateMutation;
    const res = await api.partners.functionProxyRequest(options.apiKey, query, options.token);
    return res.data.uploadUrlGenerate;
}
//# sourceMappingURL=upload.js.map