{"version":3,"file":"id-manual-matching.js","sourceRoot":"","sources":["../../../../src/cli/services/environment/id-manual-matching.ts"],"names":[],"mappings":"AAGA,OAAO,EAAC,EAAE,EAAC,MAAM,kBAAkB,CAAA;AAUnC;;;;;;;;GAQG;AACH,MAAM,CAAC,KAAK,UAAU,cAAc,CAClC,eAA4B,EAC5B,gBAAyC;IAEzC,MAAM,WAAW,GAA4B,EAAE,CAAA;IAC/C,IAAI,aAAa,GAAG,gBAAgB,CAAA;IACpC,IAAI,YAAY,GAAG,eAAe,CAAA;IAClC,KAAK,MAAM,SAAS,IAAI,eAAe,EAAE;QACvC,MAAM,oBAAoB,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,IAAI,KAAK,SAAS,CAAC,WAAW,CAAC,CAAA;QAC9F,IAAI,oBAAoB,CAAC,MAAM,KAAK,CAAC;YAAE,SAAQ;QAC/C,4CAA4C;QAC5C,MAAM,QAAQ,GAAG,MAAM,wBAAwB,CAAC,SAAS,EAAE,oBAAoB,CAAC,CAAA;QAChF,IAAI,CAAC,QAAQ;YAAE,SAAQ;QAEvB,WAAW,CAAC,SAAS,CAAC,eAAe,CAAC,GAAG,QAAQ,CAAC,IAAI,CAAA;QACtD,aAAa,GAAG,aAAa,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,IAAI,KAAK,QAAQ,CAAC,IAAI,CAAC,CAAA;QACzE,YAAY,GAAG,YAAY,CAAC,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,eAAe,KAAK,SAAS,CAAC,eAAe,CAAC,CAAA;KAC/F;IAED,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC;QAAE,OAAO,EAAC,MAAM,EAAE,gBAAgB,EAAC,CAAA;IAC/D,OAAO,EAAC,MAAM,EAAE,IAAI,EAAE,WAAW,EAAE,QAAQ,EAAE,YAAY,EAAC,CAAA;AAC5D,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,wBAAwB,CAC5C,SAAoB,EACpB,aAAsC;IAEtC,MAAM,gBAAgB,GAAG,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;QACnD,IAAI,EAAE,eAAe,GAAG,CAAC,KAAK,SAAS,GAAG,CAAC,EAAE,uBAAuB;QACpE,KAAK,EAAE,GAAG,CAAC,IAAI;KAChB,CAAC,CAAC,CAAA;IACH,gBAAgB,CAAC,IAAI,CAAC,EAAC,IAAI,EAAE,sBAAsB,EAAE,KAAK,EAAE,QAAQ,EAAC,CAAC,CAAA;IACtE,MAAM,MAAM,GAAmB,MAAM,EAAE,CAAC,MAAM,CAAC;QAC7C;YACE,IAAI,EAAE,cAAc;YACpB,IAAI,EAAE,MAAM;YACZ,OAAO,EAAE,sCAAsC,SAAS,CAAC,eAAe,IAAI;YAC5E,OAAO,EAAE,gBAAgB;SAC1B;KACF,CAAC,CAAA;IACF,OAAO,aAAa,CAAC,IAAI,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,IAAI,KAAK,MAAM,CAAC,IAAI,CAAE,CAAA;AAC/D,CAAC","sourcesContent":["import {ExtensionRegistration} from '../dev/create-extension.js'\nimport {IdentifiersExtensions} from '../../models/app/identifiers.js'\nimport {Extension} from '../../models/app/extensions.js'\nimport {ui} from '@shopify/cli-kit'\n\nexport type ManualMatchResult =\n  | {\n      result: 'ok'\n      identifiers: IdentifiersExtensions\n      toCreate: Extension[]\n    }\n  | {result: 'pending-remote'}\n\n/**\n * Prompt the user to manually match each of the local extensions to a remote extension.\n * The user can also select to create a new remote extension instead of selecting an existing one.\n * Manual matching will only show extensions of the same type as possible matches.\n * At the end of this process, all remote extensions must be matched to suceed.\n * @param localExtensions {Extension[]} The local extensions to match\n * @param remoteExtensions {ExtensionRegistration[]} The remote extensions to match\n * @returns {Promise<ManualMatchResult>} The result of the manual matching\n */\nexport async function manualMatchIds(\n  localExtensions: Extension[],\n  remoteExtensions: ExtensionRegistration[],\n): Promise<ManualMatchResult> {\n  const identifiers: {[key: string]: string} = {}\n  let pendingRemote = remoteExtensions\n  let pendingLocal = localExtensions\n  for (const extension of localExtensions) {\n    const registrationsForType = pendingRemote.filter((reg) => reg.type === extension.graphQLType)\n    if (registrationsForType.length === 0) continue\n    // eslint-disable-next-line no-await-in-loop\n    const selected = await selectRegistrationPrompt(extension, registrationsForType)\n    if (!selected) continue\n\n    identifiers[extension.localIdentifier] = selected.uuid\n    pendingRemote = pendingRemote.filter((reg) => reg.uuid !== selected.uuid)\n    pendingLocal = pendingLocal.filter((reg) => reg.localIdentifier !== extension.localIdentifier)\n  }\n\n  if (pendingRemote.length > 0) return {result: 'pending-remote'}\n  return {result: 'ok', identifiers, toCreate: pendingLocal}\n}\n\nexport async function selectRegistrationPrompt(\n  extension: Extension,\n  registrations: ExtensionRegistration[],\n): Promise<ExtensionRegistration> {\n  const registrationList = registrations.map((reg) => ({\n    name: `Match it to ${reg.title} (ID: ${reg.id} on Shopify Partners)`,\n    value: reg.uuid,\n  }))\n  registrationList.push({name: 'Create new extension', value: 'create'})\n  const choice: {uuid: string} = await ui.prompt([\n    {\n      type: 'autocomplete',\n      name: 'uuid',\n      message: `How would you like to deploy your \"${extension.localIdentifier}\"?`,\n      choices: registrationList,\n    },\n  ])\n  return registrations.find((reg) => reg.uuid === choice.uuid)!\n}\n"]}