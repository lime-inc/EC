{"version":3,"file":"id-matching.js","sourceRoot":"","sources":["../../../../src/cli/services/environment/id-matching.ts"],"names":[],"mappings":"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","sourcesContent":["import {ExtensionRegistration} from '../dev/create-extension.js'\nimport {IdentifiersExtensions} from '../../models/app/identifiers.js'\nimport {Extension} from '../../models/app/extensions.js'\n\nexport type MatchResult =\n  | {\n      result: 'ok'\n      identifiers: IdentifiersExtensions\n      pendingConfirmation: {extension: Extension; registration: ExtensionRegistration}[]\n      toCreate: Extension[]\n      toManualMatch: {local: Extension[]; remote: ExtensionRegistration[]}\n    }\n  | {\n      result: 'invalid-environment'\n    }\n\nexport async function automaticMatchmaking(\n  localExtensions: Extension[],\n  remoteRegistrations: ExtensionRegistration[],\n  identifiers: {[localIdentifier: string]: string},\n): Promise<MatchResult> {\n  if (remoteRegistrations.length > localExtensions.length) {\n    return {result: 'invalid-environment'}\n  }\n\n  const validIdentifiers = identifiers\n\n  // Get the local UUID of an extension, if exists\n  const localId = (extension: Extension) => validIdentifiers[extension.localIdentifier]\n\n  // All local UUIDs available\n  const localUUIDs = () => Object.values(validIdentifiers)\n\n  // Whether an extension has an UUID and that UUID and type match with a remote extension\n  const existsRemotely = (extension: Extension) => {\n    const remote = remoteRegistrations.find((registration) => registration.uuid === localId(extension))\n    return remote !== undefined && remote.type === extension.graphQLType\n  }\n\n  // List of local extensions that don't exists remotely and need to be matched\n  const pendingLocal = localExtensions.filter((extension) => !existsRemotely(extension))\n\n  // List of remote extensions that are not yet matched to a local extension\n  const pendingRemote = remoteRegistrations.filter((registration) => !localUUIDs().includes(registration.uuid))\n\n  // From pending to be matched remote extensions, this is the list of remote extensions with duplicated Type\n  // If two or more extensions have the same type, we need to manually match them.\n  const remoteNeedsManualMatch = (() => {\n    const types = pendingRemote.map((ext) => ext.type).filter((type, i, array) => array.indexOf(type) !== i)\n    return pendingRemote.filter((ext) => types.includes(ext.type))\n  })()\n\n  // From pending to be matched extensions, this is the list of extensions with duplicated Type\n  // If two or more extensions have the same type, we need to manually match them.\n  const localNeedsManualMatch = (() => {\n    const types = pendingLocal.map((ext) => ext.graphQLType).filter((type, i, array) => array.indexOf(type) !== i)\n    // If local extensions with duplicated types do not have a possible remote match, they don't require manual match\n    const manualTypes = types.filter((type) => remoteNeedsManualMatch.some((reg) => reg.type === type))\n    return pendingLocal.filter((ext) => manualTypes.includes(ext.graphQLType))\n  })()\n\n  // Extensions that should be possible to automatically match or create, should not contain duplicated types\n  const newLocalPending = pendingLocal.filter((extension) => !localNeedsManualMatch.includes(extension))\n  const newRemotePending = pendingRemote.filter((registration) => !remoteNeedsManualMatch.includes(registration))\n\n  // If there are remote pending with types not present locally, we can't automatically match\n  // The user must solve the issue in their environment or deploy to a different app\n  const impossible = newRemotePending.filter((reg) => !newLocalPending.map((ext) => ext.graphQLType).includes(reg.type))\n  if (impossible.length > 0 || newRemotePending.length > newLocalPending.length) {\n    return {result: 'invalid-environment'}\n  }\n\n  // If there are more remote pending than local in total, then we can't automatically match\n  // The user must solve the issue in their environment or deploy to a different app\n  if (newRemotePending.length > newLocalPending.length) {\n    return {result: 'invalid-environment'}\n  }\n\n  const extensionsToCreate: Extension[] = []\n  const pendingConfirmation: {extension: Extension; registration: ExtensionRegistration}[] = []\n\n  // For each pending local extension, evaluate if it can be automatically matched or needs to be created\n  newLocalPending.forEach((extension) => {\n    // Remote extensions that have the same type as the local one\n    const possibleMatches = newRemotePending.filter((req) => req.type === extension.graphQLType)\n\n    if (possibleMatches.length === 0) {\n      // There are no remote extensions with the same type. We need to create a new extension\n      extensionsToCreate.push(extension)\n    } else if (possibleMatches[0]!.title.toLowerCase() === extension.localIdentifier.toLowerCase()) {\n      // There is a unique remote extension with the same type AND name. We can automatically match them.\n      validIdentifiers[extension.localIdentifier] = possibleMatches[0]!.uuid\n    } else {\n      // There is a unique remote extension with the same type, but different name. We can match them but need to confirm\n      pendingConfirmation.push({extension, registration: possibleMatches[0]!})\n    }\n  })\n\n  // At this point, all extensions are matched either automatically, manually or are new\n  return {\n    result: 'ok',\n    identifiers: validIdentifiers,\n    pendingConfirmation,\n    toCreate: extensionsToCreate,\n    toManualMatch: {local: localNeedsManualMatch, remote: remoteNeedsManualMatch},\n  }\n}\n"]}